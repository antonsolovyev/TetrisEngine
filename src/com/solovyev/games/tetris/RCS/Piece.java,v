head	1.4;
access;
symbols;
locks; strict;
comment	@# @;


1.4
date	2010.01.21.04.30.32;	author solovam;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.20.04.27.16;	author solovam;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.20.03.26.31;	author solovam;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.16.08.47.57;	author solovam;	state Exp;
branches;
next	;


desc
@@


1.4
log
@*** empty log message ***
@
text
@/*
 * $Id: Piece.java,v 1.3 2010/01/20 04:27:16 solovam Exp solovam $
 */
package com.solovyev.games.tetris;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class Piece implements Serializable
{
        private static final long serialVersionUID = 0L;        
        private List<Cell> cells;
        private double centerX;
        private double centerY;
        
        public static final Piece NULL = new Piece(new HashSet<Cell>(), 0, 0);
        /** Super Rotation System: I and O pieces rotate around cell intersections */
        public static final Piece I = new Piece(new int[][]{{0, 1}, {1, 1}, {2, 1}, {3, 1}}, Cell.Color.CYAN, 1.5, 1.5);
        public static final Piece J = new Piece(new int[][]{{0, 0}, {0, 1}, {1, 1}, {2, 1}}, Cell.Color.BLUE, 1, 1);
        public static final Piece L = new Piece(new int[][]{{0, 1}, {1, 1}, {2, 1}, {2, 0}}, Cell.Color.ORANGE, 1, 1);
        public static final Piece O = new Piece(new int[][]{{1, 0}, {2, 0}, {1, 1}, {2, 1}}, Cell.Color.YELLOW, 1.5, 0.5);                    
        public static final Piece S = new Piece(new int[][]{{1, 0}, {2, 0}, {0, 1}, {1, 1}}, Cell.Color.GREEN, 1, 1);
        public static final Piece T = new Piece(new int[][]{{1, 0}, {0, 1}, {1, 1}, {2, 1}}, Cell.Color.PURPLE, 1, 1);
        public static final Piece Z = new Piece(new int[][]{{0, 0}, {1, 0}, {1, 1}, {2, 1}}, Cell.Color.RED, 1, 1);
        
        enum Direction
        {
                COUNTERCLOCKWISE(-1), CLOCKWISE(1);
                
                private int value;
                
                private Direction(int value)
                {
                        this.value = value;
                }
                
                public int getValue()
                {
                        return value;
                }
        }
        
        public Piece(Collection<Cell> cells, double centerX, double centerY)
        {
                this.cells = new ArrayList<Cell>(cells);
                this.centerX = centerX;
                this.centerY = centerY;
        }
        
        public Piece(int[][] cellCoordinates, Cell.Color color, double centerX, double centerY)
        {
                cells = new ArrayList<Cell>();
                for(int i = 0; i < cellCoordinates.length; i++)
                        cells.add(new Cell(cellCoordinates[i][0], cellCoordinates[i][1], color));
                this.centerX = centerX;
                this.centerY = centerY;
        }
        
        public List<Cell> getCells()
        {
                return new ArrayList<Cell>(cells);
        }
        
        public double getCenterX()
        {
                return centerX;
        }

        public double getCenterY()
        {
                return centerY;
        }
        
        public String toString()
        {
                return "cells: " + cells + " center X: " + centerX + " center Y: " + centerY;
        }
                
        public Piece makeTranslated(int x, int y)
        {
                Set<Cell> newCells = new HashSet<Cell>();
                
                for(Cell c : getCells())
                        newCells.add(new Cell(c.getX() + x, c.getY() + y, c.getColor()));
                
                return new Piece(newCells, centerX + x, centerY + y);
        }

        public Piece makeRotated(Direction direction)
        {
                Set<Cell> newCells = new HashSet<Cell>();
                
                for(Cell c : getCells())
                        newCells.add(new Cell((int) (direction.getValue() * (centerY - c.getY()) + centerX),
                                        (int) (direction.getValue() * (c.getX() - centerX) + centerY), c.getColor()));
                
                return new Piece(newCells, centerX, centerY);
        }
}@


1.3
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: Piece.java,v 1.2 2010/01/20 03:26:31 solovam Exp solovam $
d17 2
a18 1
        private Cell center;
d20 9
a28 1
        public static final Piece NULL_PIECE = new Piece(new HashSet<Cell>(), new Cell(0, 0, Cell.Color.NULL));
d47 1
a47 1
        public Piece(Collection<Cell> cells, Cell center)
d50 2
a51 1
                this.center = center;
d54 1
a54 1
        public Piece(int[][] cellCoordinates, Cell.Color color, Cell center)
d59 2
a60 1
                this.center = center;
d68 1
a68 1
        public Cell getCenter()
d70 6
a75 1
                return center;
d80 1
a80 1
                return "cells: " + cells + " center: " + center;
d85 1
a85 1
                Set<Cell> res = new HashSet<Cell>();
d88 1
a88 1
                        res.add(new Cell(c.getX() + x, c.getY() + y, c.getColor()));
d90 1
a90 1
                return new Piece(res, new Cell(getCenter().getX() + x, getCenter().getY() + y, getCenter().getColor()));
d95 1
a95 1
                Set<Cell> res = new HashSet<Cell>();
d98 4
a101 6
                        res.add(new Cell(
                                        direction.getValue() * (getCenter().getY() - c.getY()) + getCenter().getX(),
                                        direction.getValue() * (c.getX() - getCenter().getX()) + getCenter().getY(),
                                        c.getColor())
                        );                
                return new Piece(res, getCenter());
@


1.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: Piece.java,v 1.1 2010/01/16 08:47:57 solovam Exp solovam $
a88 9

        public boolean isOverlapping(Collection<Cell> cells)
        {
                for(Cell i : cells)
                        for(Cell j : getCells())
                                if(j.getX() == i.getX() && j.getY() == i.getY())
                                        return true;
                return false;
        }
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id$
a8 1
import java.util.Collections;
d54 1
a54 1
                return Collections.unmodifiableList(cells);
@
