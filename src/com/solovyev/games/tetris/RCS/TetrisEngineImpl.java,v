head	1.10;
access;
symbols;
locks; strict;
comment	@# @;


1.10
date	2013.02.09.05.16.18;	author solovam;	state Exp;
branches;
next	1.9;

1.9
date	2010.12.11.00.50.50;	author solovam;	state Exp;
branches;
next	1.8;

1.8
date	2010.02.02.06.13.57;	author solovam;	state Exp;
branches;
next	1.7;

1.7
date	2010.01.24.07.47.45;	author solovam;	state Exp;
branches;
next	1.6;

1.6
date	2010.01.22.17.29.29;	author solovam;	state Exp;
branches;
next	1.5;

1.5
date	2010.01.21.04.30.20;	author solovam;	state Exp;
branches;
next	1.4;

1.4
date	2010.01.20.21.09.57;	author solovam;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.20.04.27.22;	author solovam;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.20.03.26.25;	author solovam;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.16.08.47.58;	author solovam;	state Exp;
branches;
next	;


desc
@@


1.10
log
@*** empty log message ***
@
text
@/*
 * $Id: TetrisEngineImpl.java,v 1.9 2010/12/11 00:50:50 solovam Exp solovam $
 */
package com.solovyev.games.tetris;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.Timer;
import java.util.TimerTask;

public class TetrisEngineImpl extends AbstractTetrisEngine
{
        private Timer timer;
    
        public TetrisEngineImpl(int width, int height)
        {
                super(width, height);
        }

        @@Override
        protected void startTimer()
        {
                timer = new Timer();
                
                timer.scheduleAtFixedRate(
                                new TimerTask()
                                {
                                        public void run()
                                        {
                                                timerEvent();
                                        }
                                }, 0, getTimerTick());
        }
        
        @@Override
        protected void stopTimer()
        {
                if(timer != null)
                {
                        timer.cancel();
                        timer = null;
                }
        }
}@


1.9
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: TetrisEngineImpl.java,v 1.8 2010/02/02 06:13:57 solovam Exp solovam $
d12 1
a12 1
public class TetrisEngineImpl implements TetrisEngine
a13 26
        private final static int INITIAL_DELAY = 30;
        private final static int FREEFALL_DELAY = 1;
        private final static int LINE_COST = 30;
        private final static int PIECE_COST = 10;
        private final static int SCORE_PER_SPEED = 800;
        private final static double ACCELERATION_FACTOR = 1.2;
        private final static int TIMERTICK = 20;

        private int width;
        private int height;
        
        private int lineCount;
        private int pieceCount;
        private int score;
        private int speed;
        
        private int delay;
        // Number of timer ticks until next game move
        private int moveTimer;
        
        private GameState gameState;
        
        private Piece nextPiece;
        private Piece piece;
        private Piece[] pieces = makePieces(); 
        
d15 1
a15 7
        
        private List<Cell> sea;
        
        private Random random = new Random(System.currentTimeMillis());

        private List<TetrisListener> listenerList = new ArrayList<TetrisListener>();

d18 1
a18 8
                this.width = width;
                this.height = height;
                
                initParameters();                
                initSea();                
                initPieces();
                
                gameState = GameState.IDLE;
d21 2
a22 154
        public synchronized void start()
        {
                if(gameState == GameState.IDLE)
                {
                        gameState = GameState.RUNNING;                
                        startTimer();                
                        postUpdate();
                }
        }
        
        public synchronized void stop()
        {
                if(gameState != GameState.IDLE)
                {
                        stopTimer();
                        
                        initParameters();                
                        initSea();                
                        initPieces();
                        
                        gameState = GameState.IDLE;
                        postUpdate();
                }
        }
        
        public synchronized void pause()
        {
                if(gameState == GameState.RUNNING)
                {
                        gameState = GameState.PAUSED;
                        stopTimer();
                        postUpdate();
                }                
        }
        
        public synchronized void resume()
        {
                if(gameState == GameState.PAUSED)
                {        
                        gameState = GameState.RUNNING;
                        startTimer();
                        postUpdate();
                }                
        }

        private void initParameters()
        {
                lineCount = 0;
                pieceCount = 0;
                score = 0;
                speed = 1;                
                delay = INITIAL_DELAY;
                moveTimer = 0;
        }

        private void initSea()
        {
                sea = new ArrayList<Cell>();
        }
        
        private void initPieces()
        {
                piece = Piece.NULL;
                nextPiece = getRandomPiece();
        }
        
        public synchronized void movePieceLeft()
        {
                if(isInputAccepted())
                        translatePiece(-1, 0);                
        }

        public synchronized void movePieceRight()
        {
                if(isInputAccepted())
                        translatePiece(1, 0);
        }
        
        public synchronized void rotatePieceCounterclockwise()
        {
                if(isInputAccepted())
                        rotatePiece(Piece.Direction.COUNTERCLOCKWISE);
        }
        
        public synchronized void rotatePieceClockwise()
        {
                if(isInputAccepted())
                        rotatePiece(Piece.Direction.CLOCKWISE);
        }
        
        public synchronized void dropPiece()
        {
                if(gameState == GameState.RUNNING)
                        freeFall();
        }
        
        private boolean isInputAccepted()
        {
                if(gameState == GameState.RUNNING || gameState == GameState.FREEFALL)
                        return true;
                return false;
        }
        
        public synchronized Piece getPiece()
        {
                return piece;
        }
        
        public synchronized List<Cell> getSea()
        {
                return new ArrayList<Cell>(sea);
        }
        
        public synchronized Piece getNextPiece()
        {
                return nextPiece;
        }
        
        public int getHeight()
        {
                return height;
        }
        
        public int getWidth()
        {
                return width;
        }
        
        public synchronized int getScore()
        {
                return score;
        }
        
        public synchronized GameState getGameState()
        {
                return gameState;
        }
        
        public synchronized int getLineCount()
        {
                return lineCount;
        }
        
        public synchronized int getSpeed()
        {
                return speed;
        }
        
        public synchronized int getPieceCount()
        {
                return pieceCount;
        }
        
        private void startTimer()
d33 1
a33 1
                                }, 0, TIMERTICK);
d36 2
a37 1
        private void stopTimer()
a44 298

        private boolean isInside(Cell cell)
        {
                if(cell.getX() >= 0 && cell.getX() < width && cell.getY() >= 0 && cell.getY() < height)
                        return(true);
                return(false);
        }

        private boolean isInside(Piece piece)
        {
                for(Cell c : piece.getCells())
                        if(!isInside(c))
                                return false;
                return true;
        }

        private static Piece[] makePieces()
        {
                Piece[] res = new Piece[]
                {
                        Piece.I,
                        Piece.J,
                        Piece.L,
                        Piece.O,
                        Piece.S,
                        Piece.T,
                        Piece.Z,
                };                                
                return res;
        }
        
        private Piece getRandomPiece()
        {
                return pieces[random.nextInt(pieces.length)];
        }

        private int pumpoutSea()
        {
                int full_lines = 0;

                for(int i = 0; i < height; i++)
                {
                        boolean full_line = true;
                        for(int j = 0; j < width; j++)
                        {
                                if(!isSeaContaining(j, i))
                                {
                                        full_line = false;
                                        break;
                                }
                        }
                        if(full_line)
                        {
                                full_lines++;

                                List<Cell> newSea = new ArrayList<Cell>();
                                for(Cell c : sea)
                                {
                                        if(c.getY() < i)
                                                newSea.add(new Cell(c.getX(), c.getY() + 1, c.getColor()));
                                        else
                                                if(c.getY() > i)
                                                        newSea.add(c);
                                }
                                sea = newSea;
                        }
                }
                
                return(full_lines);
        }
        
        private boolean isSeaContaining(Cell cell)
        {
                return isSeaContaining(cell.getX(), cell.getY());
        }
        
        private boolean isSeaContaining(int x, int y)
        {
                for(Cell c : sea)
                        if(c.getX() == x && c.getY() == y)
                                return true;
                return false;
        }
        
        private boolean isSeaOverlapping(Piece piece)
        {
                for(Cell c : piece.getCells())
                        if(isSeaContaining(c))
                                return true;
                return false;
        }

        private void freeFall()
        {
                if(gameState == GameState.RUNNING)
                {
                        gameState = GameState.FREEFALL;
                        moveTimer = 0;
                }
        }

        private boolean translatePiece(int x, int y)
        {
                if(piece == Piece.NULL)
                        return false;
                        
                Piece newPiece = piece.makeTranslated(x, y);

                if(isSeaOverlapping(newPiece) || !isInside(newPiece))
                        return false;
                
                piece = newPiece;

                postUpdate();
                
                return true;
        }

        private boolean rotatePiece(Piece.Direction direction)
        {
                if(piece == Piece.NULL)
                        return false;

                Piece newPiece = piece.makeRotated(direction);

                if(isSeaOverlapping(newPiece) || !isInside(newPiece))
                        return false;
                
                piece = newPiece;

                postUpdate();
                
                return true;
        }

        private void sinkPiece()
        {
                if(piece == Piece.NULL)
                        return;

                sea.addAll(piece.getCells());
                
                piece = Piece.NULL;
                
                lineCount += pumpoutSea();

                adjustScoreSpeedDelay();
                
                postUpdate();                
        }

        private void newPiece()
        {
                piece = nextPiece.makeTranslated(width / 2 - 2, 0);
                if(isSeaOverlapping(piece))
                {
                        gameOver();
                        return;
                }
                
                pieceCount++;
                
                adjustScoreSpeedDelay();
                
                nextPiece = getRandomPiece();
                
                moveTimer = delay;
                
                postUpdate();
        }
        
        private void gameOver()
        {
                stopTimer();
                piece = Piece.NULL;
                gameState = GameState.GAMEOVER;
                postUpdate();
        }

        private void adjustScoreSpeedDelay()
        {
                score = lineCount * LINE_COST + pieceCount * PIECE_COST;
                speed = speed < 10 ? score / SCORE_PER_SPEED + 1 : 10;
                delay = (int) (INITIAL_DELAY / Math.exp(Math.log(ACCELERATION_FACTOR) * (speed - 1)));
                postUpdate();
        }
        
        private void postUpdate()
        {
                fireStateChanged();
        }

        synchronized public void timerEvent()
        {
                if(moveTimer != 0)
                {
                        moveTimer--;
                        return;
                }

                switch(gameState)
                {
                case RUNNING:
                        if(piece == Piece.NULL)
                        {
                                newPiece();
                                break;
                        }

                        if(!translatePiece(0, 1))
                        {
                                sinkPiece();
                                break;
                        }
                        
                        moveTimer = delay;
                        
                        break;

                case FREEFALL:
                        if(piece == Piece.NULL)
                        {
                                gameState = GameState.RUNNING;
                                break;
                        }

                        if(!translatePiece(0, 1))
                        {
                                sinkPiece();
                                break;
                        }
                        
                        moveTimer = FREEFALL_DELAY;
                        
                        break;

                default:
                        break;
                }
        }
        
        public synchronized String toString()
        {
                String res = "";
                
                res += "width: " + width + ", ";
                res += "height: " + height + ", ";
                res += "lineCount: " + lineCount + ", ";
                res += "pieceCount: " + pieceCount + ", ";
                res += "score: " + score + ", ";
                res += "speed: " + speed + ", ";
                res += "delay: " + delay + ", ";
                res += "moveTimer: " + moveTimer + ", ";
                res += "gameState: " + gameState + ", ";
                res += "nextPiece: " + nextPiece + ", ";
                res += "piece: " + piece + ", ";
                res += "sea: " + sea;
                
                return res;
        }
        
        public synchronized void destroy()
        {
                stopTimer();
        }

        @@Override
        public synchronized void addTetrisListener(TetrisListener l)
        {
                if(!listenerList.contains(l))
                        listenerList.add(l);
        }
        
        @@Override
        public synchronized void removeTetrisListener(TetrisListener l)
        {
                if(listenerList.contains(l))
                        listenerList.remove(l);
        }

        @@Override
        public TetrisListener[] getTetrisListeners()
        {
                return listenerList.toArray(new TetrisListener[]{});
        }

        protected void fireStateChanged()
        {
                TetrisListener[] localListenerList;
                
                synchronized(this)
                {
                        localListenerList = getTetrisListeners();
                }

                for(TetrisListener l : localListenerList)
                        l.stateChanged(new TetrisEvent(this));
        }
@


1.8
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: TetrisEngineImpl.java,v 1.7 2010/01/24 07:47:45 solovam Exp solovam $
a7 1
import java.util.Observable;
d12 1
a12 1
public class TetrisEngineImpl extends Observable implements TetrisEngine
d45 3
a47 1
        
d424 1
a424 2
                setChanged();
                notifyObservers();
d496 1
a496 1
        protected void finalize() throws Throwable
d498 35
a532 14
                 try
                 {
                         destroy();
                 }
                 finally
                 {
                         super.finalize();
                 }
         }
         
         public synchronized void destroy()
         {
                 stopTimer();
         }
@


1.7
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: TetrisEngineImpl.java,v 1.6 2010/01/22 17:29:29 solovam Exp solovam $
d127 2
a128 4
                if(gameState != GameState.RUNNING)
                        return;
                
                translatePiece(-1, 0);                
d133 2
a134 4
                if(gameState != GameState.RUNNING)
                        return;
                
                translatePiece(1, 0);
d139 2
a140 4
                if(gameState != GameState.RUNNING)
                        return;
                
                rotatePiece(Piece.Direction.COUNTERCLOCKWISE);
d145 2
a146 4
                if(gameState != GameState.RUNNING)
                        return;
                
                rotatePiece(Piece.Direction.CLOCKWISE);
d151 9
a159 4
                if(gameState != GameState.RUNNING)
                        return;
                
                freeFall();
@


1.6
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: TetrisEngineImpl.java,v 1.5 2010/01/21 04:30:20 solovam Exp solovam $
d84 1
a84 1
        public synchronized void pauseResume()
d86 1
a86 1
                switch(gameState)
a87 1
                case RUNNING:
d91 7
a97 2
                        break;
                case PAUSED:
a100 3
                        break;
                default:
                        break;                       
d103 1
a103 1
        
@


1.5
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: TetrisEngineImpl.java,v 1.4 2010/01/20 21:09:57 solovam Exp solovam $
d126 3
d134 3
d142 3
d150 3
d158 3
@


1.4
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: TetrisEngineImpl.java,v 1.3 2010/01/20 04:27:22 solovam Exp solovam $
d120 1
a120 1
                piece = Piece.NULL_PIECE;
d124 1
a124 1
        public synchronized void keyEvent(Key key)
d126 21
a146 23
                switch(key)
                {
                case LEFT:
                        translatePiece(-1, 0);
                        break;
                case RIGHT:
                        translatePiece(1, 0);
                        break;
                case UP:
                        rotatePiece(Piece.Direction.COUNTERCLOCKWISE);
                        break;
                case DOWN:
                        rotatePiece(Piece.Direction.CLOCKWISE);
                        break;
                case SPACE:
                        freeFall();
                        break;
                case PAUSE:
                        pauseResume();
                        break;
                default:
                        break;
                }
a238 1
                Cell center = new Cell(0, 1, Cell.Color.NULL);                
d241 7
a247 7
                       new Piece(new int[][]{{-1, 1}, {0, 1}, {0, 2}, {1, 2}}, Cell.Color.RED, center),         // Z
                       new Piece(new int[][]{{-1, 2}, {0, 2}, {0, 1}, {1, 1}}, Cell.Color.GREEN, center),       // S
                       new Piece(new int[][]{{-1, 2}, {-1, 1}, {0, 1}, {1, 1}}, Cell.Color.ORANGE, center),     // L
                       new Piece(new int[][]{{-1, 1}, {0, 1}, {1, 1}, {1, 2}}, Cell.Color.BLUE, center),        // J
                       new Piece(new int[][]{{0, 0}, {0, 1}, {0, 2}, {0, 3}}, Cell.Color.CYAN, center),         // I
                       new Piece(new int[][]{{-1, 2}, {0, 1}, {0, 2}, {1, 2}}, Cell.Color.PURPLE, center),      // T
                       new Piece(new int[][]{{0, 1}, {1, 1}, {0, 2}, {1, 2}}, Cell.Color.YELLOW, center),       // O            
d266 1
a266 2
                                Cell c = new Cell(j, i, Cell.Color.NULL);
                                if(!isSeaContaining(c))
d294 5
d300 1
a300 1
                        if(c.getX() == cell.getX() && c.getY() == cell.getY())
d324 1
a324 1
                if(piece == Piece.NULL_PIECE)
d341 1
a341 1
                if(piece == Piece.NULL_PIECE)
d358 1
a358 1
                if(piece == Piece.NULL_PIECE)
d363 1
a363 1
                piece = Piece.NULL_PIECE;
d374 1
a374 2
                int middle = (width - width % 2) / 2;
                piece = nextPiece.makeTranslated(middle, 0);
d387 2
d395 1
a395 1
                piece = Piece.NULL_PIECE;
d425 1
a425 1
                        if(piece == Piece.NULL_PIECE)
d428 1
d442 1
a442 1
                        if(piece == Piece.NULL_PIECE)
@


1.3
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: TetrisEngineImpl.java,v 1.2 2010/01/20 03:26:25 solovam Exp solovam $
d244 7
a250 7
                       new Piece(new int[][]{{-1, 1}, {0, 1}, {0, 2}, {1, 2}}, Cell.Color.CYAN, center),
                       new Piece(new int[][]{{-1, 2}, {0, 2}, {0, 1}, {1, 1}}, Cell.Color.BLUE, center),
                       new Piece(new int[][]{{-1, 2}, {-1, 1}, {0, 1}, {1, 1}}, Cell.Color.ORANGE, center),
                       new Piece(new int[][]{{-1, 1}, {0, 1}, {1, 1}, {1, 2}}, Cell.Color.YELLOW, center),
                       new Piece(new int[][]{{0, 0}, {0, 1}, {0, 2}, {0, 3}}, Cell.Color.GREEN, center),
                       new Piece(new int[][]{{-1, 2}, {0, 1}, {0, 2}, {1, 2}}, Cell.Color.PURPLE, center),
                       new Piece(new int[][]{{0, 1}, {1, 1}, {0, 2}, {1, 2}}, Cell.Color.RED, center),                       
@


1.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * $Id: TetrisEngineImpl.java,v 1.1 2010/01/16 08:47:58 solovam Exp solovam $
d151 1
a151 1
        public Piece getPiece()
d156 1
a156 1
        public List<Cell> getSea()
d161 1
a161 1
        public Piece getNextPiece()
d176 1
a176 1
        public int getScore()
d181 1
a181 1
        public GameState getGameState()
d186 1
a186 1
        public int getLineCount()
d191 1
a191 1
        public int getSpeed()
d196 1
a196 1
        public int getPieceCount()
d270 1
a270 1
                                if(!sea.contains(c))
d295 16
d328 1
a328 1
                if(newPiece.isOverlapping(sea) || !isInside(newPiece))
d345 1
a345 1
                if(newPiece.isOverlapping(sea) || !isInside(newPiece))
d375 1
a375 1
                if(piece.isOverlapping(sea))
d460 1
a460 1
        public String toString()
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id$
d158 1
a158 1
                return sea;
@
